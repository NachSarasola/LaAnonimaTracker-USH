"""Reporting module for La Anónima Price Tracker.

Generates an HTML report (and optional PDF) for a selected date range.
"""

from __future__ import annotations

import json
from dataclasses import dataclass
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Dict, Optional

import pandas as pd
from loguru import logger

from src.config_loader import get_basket_items, load_config, resolve_canonical_category
from src.models import CategoryIndex, Price, Product, get_engine, get_session_factory


@dataclass
class ReportArtifacts:
    """Artifact paths generated by the reporting job."""

    html_path: str
    metadata_path: str
    pdf_path: Optional[str] = None


class ReportGenerator:
    """Build HTML/PDF report for inflation and coverage metrics."""

    def __init__(self, config: Dict[str, Any]):
        self.config = config
        engine = get_engine(config)
        session_factory = get_session_factory(engine)
        self.session = session_factory()

    def close(self):
        self.session.close()

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()

    def _month_start(self, value: str) -> pd.Timestamp:
        ts = pd.to_datetime(value, format="%Y-%m")
        return ts.to_period("M").to_timestamp()

    def _next_month_start(self, value: str) -> pd.Timestamp:
        return self._month_start(value) + pd.offsets.MonthBegin(1)

    def _load_prices(self, from_month: str, to_month: str, basket_type: str) -> pd.DataFrame:
        start_dt = self._month_start(from_month)
        end_exclusive_dt = self._next_month_start(to_month)

        query = (
            self.session.query(
                Price.canonical_id,
                Price.product_name,
                Price.basket_id,
                Price.current_price,
                Price.scraped_at,
                Product.category,
            )
            .outerjoin(Product, Price.canonical_id == Product.canonical_id)
            .filter(Price.scraped_at >= start_dt)
            .filter(Price.scraped_at < end_exclusive_dt)
        )

        if basket_type != "all":
            query = query.filter(Price.basket_id == basket_type)

        df = pd.read_sql(query.statement, self.session.bind)
        if df.empty:
            return df

        df["scraped_at"] = pd.to_datetime(df["scraped_at"])
        df["month"] = df["scraped_at"].dt.to_period("M").astype(str)
        df["current_price"] = pd.to_numeric(df["current_price"], errors="coerce")
        df["category"] = df["category"].fillna("sin_categoria")
        return df.dropna(subset=["current_price"])

    def _monthly_avg_by(self, df: pd.DataFrame, group_col: str) -> pd.DataFrame:
        grouped = (
            df.groupby([group_col, "month"], as_index=False)["current_price"]
            .mean()
            .sort_values([group_col, "month"])
        )
        return grouped

    def _variation_between_months(self, grouped_df: pd.DataFrame, group_col: str, from_month: str, to_month: str) -> pd.DataFrame:
        from_df = grouped_df[grouped_df["month"] == from_month][[group_col, "current_price"]].rename(
            columns={"current_price": "price_from"}
        )
        to_df = grouped_df[grouped_df["month"] == to_month][[group_col, "current_price"]].rename(
            columns={"current_price": "price_to"}
        )
        merged = from_df.merge(to_df, on=group_col, how="inner")
        if merged.empty:
            return merged

        valid_price_from = merged["price_from"].notna() & (merged["price_from"] > 0)
        merged["variation_pct"] = pd.NA
        merged.loc[valid_price_from, "variation_pct"] = (
            (merged.loc[valid_price_from, "price_to"] - merged.loc[valid_price_from, "price_from"])
            / merged.loc[valid_price_from, "price_from"]
        ) * 100

        return merged.sort_values("variation_pct", ascending=False, na_position="last")

    def _expected_products_by_category(self, basket_type: str) -> Dict[str, int]:
        expected_by_category: Dict[str, int] = {}

        for item in get_basket_items(self.config, basket_type):
            raw_category = item.get("category") or "sin_categoria"
            category = resolve_canonical_category(self.config, raw_category) or raw_category
            expected_by_category[category] = expected_by_category.get(category, 0) + 1

        return expected_by_category

    def _coverage_metrics(self, df: pd.DataFrame, from_month: str, to_month: str, basket_type: str) -> Dict[str, Any]:
        expected_by_category = self._expected_products_by_category(basket_type)
        expected_products = sum(expected_by_category.values())
        observed_total = int(df["canonical_id"].nunique()) if not df.empty else 0

        observed_from = int(df[df["month"] == from_month]["canonical_id"].nunique()) if not df.empty else 0
        observed_to = int(df[df["month"] == to_month]["canonical_id"].nunique()) if not df.empty else 0

        safe_expected = expected_products if expected_products > 0 else 1
        coverage_by_category = []
        if not df.empty:
            for category, observed in (
                df.groupby("category")["canonical_id"].nunique().sort_values(ascending=False).items()
            ):
                expected = expected_by_category.get(category, 0)
                safe_expected_category = expected if expected > 0 else 1
                coverage_by_category.append(
                    {
                        "category": category,
                        "expected_products": int(expected),
                        "observed_products": int(observed),
                        "coverage_pct": (int(observed) / safe_expected_category) * 100,
                    }
                )

        return {
            "basket_type": basket_type,
            "expected_products": expected_products,
            "expected_products_by_category": expected_by_category,
            "observed_products_total": observed_total,
            "coverage_total_pct": (observed_total / safe_expected) * 100,
            "observed_from": observed_from,
            "observed_to": observed_to,
            "coverage_from_pct": (observed_from / safe_expected) * 100,
            "coverage_to_pct": (observed_to / safe_expected) * 100,
            "coverage_by_category": coverage_by_category,
        }

    def _load_category_indices(self, from_month: str, to_month: str, basket_type: str) -> pd.DataFrame:
        query = (
            self.session.query(
                CategoryIndex.basket_type,
                CategoryIndex.category,
                CategoryIndex.year_month,
                CategoryIndex.index_value,
                CategoryIndex.mom_change,
                CategoryIndex.yoy_change,
                CategoryIndex.products_included,
                CategoryIndex.products_missing,
            )
            .filter(CategoryIndex.year_month.in_([from_month, to_month]))
        )

        if basket_type != "all":
            query = query.filter(CategoryIndex.basket_type == basket_type)

        df = pd.read_sql(query.statement, self.session.bind)
        if df.empty:
            return df

        numeric_cols = [
            "index_value",
            "mom_change",
            "yoy_change",
            "products_included",
            "products_missing",
        ]
        for col in numeric_cols:
            df[col] = pd.to_numeric(df[col], errors="coerce")

        return df

    def _category_variation_from_indices(self, from_month: str, to_month: str, basket_type: str) -> pd.DataFrame:
        indices_df = self._load_category_indices(from_month, to_month, basket_type)
        if indices_df.empty:
            return pd.DataFrame()

        from_df = indices_df[indices_df["year_month"] == from_month].copy()
        to_df = indices_df[indices_df["year_month"] == to_month].copy()

        if from_df.empty or to_df.empty:
            return pd.DataFrame()

        merged = from_df.merge(
            to_df,
            on=["basket_type", "category"],
            suffixes=("_from", "_to"),
            how="inner",
        )
        if merged.empty:
            return pd.DataFrame()

        merged["variation_pct"] = (
            (merged["index_value_to"] - merged["index_value_from"]) / merged["index_value_from"]
        ) * 100

        enriched = merged.rename(
            columns={
                "index_value_from": "price_from",
                "index_value_to": "price_to",
                "mom_change_to": "mom_change",
                "yoy_change_to": "yoy_change",
                "products_included_to": "products_included",
                "products_missing_to": "products_missing",
            }
        )

        return enriched.sort_values("variation_pct", ascending=False)

    def _render_html(
        self,
        from_month: str,
        to_month: str,
        inflation_total_pct: float,
        top_categories: pd.DataFrame,
        top_products: pd.DataFrame,
        coverage: Dict[str, Any],
        generated_at: str,
    ) -> str:
        def _fmt_float(value: Any) -> str:
            if pd.isna(value):
                return "N/D"
            return f"{float(value):.2f}%"

        def _fmt_decimal(value: Any) -> str:
            if pd.isna(value):
                return "N/D"
            return f"{float(value):.2f}"

        def _fmt_int(value: Any) -> str:
            if pd.isna(value):
                return "N/D"
            return str(int(value))

        categories_rows = "".join(
            f"<tr><td>{row['category']}</td><td>{_fmt_decimal(row['price_from'])}</td><td>{_fmt_decimal(row['price_to'])}</td><td>{_fmt_float(row['variation_pct'])}</td><td>{_fmt_float(row.get('mom_change'))}</td><td>{_fmt_float(row.get('yoy_change'))}</td><td>{_fmt_int(row.get('products_included'))}</td><td>{_fmt_int(row.get('products_missing'))}</td></tr>"
            for _, row in top_categories.iterrows()
        ) or "<tr><td colspan='8'>Sin datos suficientes</td></tr>"

        products_rows = "".join(
            f"<tr><td>{row['canonical_id']}</td><td>{row['product_name']}</td><td>{_fmt_decimal(row['price_from'])}</td><td>{_fmt_decimal(row['price_to'])}</td><td>{_fmt_float(row['variation_pct'])}</td></tr>"
            for _, row in top_products.iterrows()
        ) or "<tr><td colspan='5'>Sin datos suficientes</td></tr>"

        category_coverage_rows = "".join(
            (
                f"<tr><td>{item['category']}</td><td>{item['observed_products']}</td><td>{item['expected_products']}</td>"
                f"<td>{item['coverage_pct']:.2f}%</td></tr>"
            )
            for item in coverage.get("coverage_by_category", [])
        ) or "<tr><td colspan='4'>Sin datos suficientes</td></tr>"

        return f"""
<!DOCTYPE html>
<html lang=\"es\">
<head>
  <meta charset=\"UTF-8\" />
  <title>Reporte de inflación - La Anónima Tracker</title>
  <style>
    body {{ font-family: Arial, sans-serif; margin: 24px; color: #1f2937; }}
    h1, h2 {{ color: #111827; }}
    .muted {{ color: #6b7280; font-size: 14px; }}
    .card {{ border: 1px solid #e5e7eb; border-radius: 10px; padding: 14px; margin-bottom: 18px; }}
    .metric {{ font-size: 28px; font-weight: bold; color: #0f766e; }}
    table {{ width: 100%; border-collapse: collapse; margin-top: 10px; }}
    th, td {{ border: 1px solid #e5e7eb; padding: 8px; text-align: left; }}
    th {{ background: #f3f4f6; }}
  </style>
</head>
<body>
  <h1>Reporte de inflación de canasta</h1>
  <p class=\"muted\">Generado: {generated_at} | Rango analizado: {from_month} → {to_month}</p>

  <section class=\"card\">
    <h2>Inflación total canasta</h2>
    <p class=\"metric\">{inflation_total_pct:.2f}%</p>
  </section>

  <section class=\"card\">
    <h2>Top categorías con mayor suba</h2>
    <table>
      <thead><tr><th>Categoría</th><th>Índice inicial</th><th>Índice final</th><th>Variación</th><th>MoM</th><th>YoY</th><th>Productos incluidos</th><th>Productos faltantes</th></tr></thead>
      <tbody>{categories_rows}</tbody>
    </table>
  </section>

  <section class=\"card\">
    <h2>Top productos con mayor variación</h2>
    <table>
      <thead><tr><th>ID canónico</th><th>Producto</th><th>Precio inicial</th><th>Precio final</th><th>Variación</th></tr></thead>
      <tbody>{products_rows}</tbody>
    </table>
  </section>

  <section class=\"card\">
    <h2>Cobertura de datos</h2>
    <p class=\"muted\">Cobertura sobre {coverage['expected_products']} productos esperados (canasta: {coverage['basket_type']}).</p>
    <ul>
      <li>Productos esperados (config): {coverage['expected_products']}</li>
      <li>Productos observados (rango): {coverage['observed_products_total']} ({coverage['coverage_total_pct']:.2f}%)</li>
      <li>Productos observados en {from_month}: {coverage['observed_from']} ({coverage['coverage_from_pct']:.2f}%)</li>
      <li>Productos observados en {to_month}: {coverage['observed_to']} ({coverage['coverage_to_pct']:.2f}%)</li>
    </ul>
    <h3>Cobertura por categoría</h3>
    <table>
      <thead><tr><th>Categoría</th><th>Observados</th><th>Esperados</th><th>Cobertura</th></tr></thead>
      <tbody>{category_coverage_rows}</tbody>
    </table>
  </section>
</body>
</html>
"""

    def _write_pdf_if_requested(self, html_content: str, pdf_path: Path) -> Optional[str]:
        try:
            from weasyprint import HTML
        except Exception:
            logger.warning("No se pudo exportar PDF: weasyprint no está disponible")
            return None

        HTML(string=html_content).write_pdf(str(pdf_path))
        return str(pdf_path)

    def generate(self, from_month: str, to_month: str, export_pdf: bool = False, basket_type: str = "cba") -> Dict[str, Any]:
        if self._month_start(to_month) < self._month_start(from_month):
            raise ValueError("El rango es inválido: --to debe ser mayor o igual que --from")

        if basket_type not in {"cba", "extended", "all"}:
            raise ValueError("basket_type inválido: use cba, extended o all")

        df = self._load_prices(from_month, to_month, basket_type)
        if df.empty:
            raise ValueError("No hay datos de precios para el rango indicado")

        basket_monthly = df.groupby("month", as_index=False)["current_price"].mean()
        from_avg = basket_monthly.loc[basket_monthly["month"] == from_month, "current_price"]
        to_avg = basket_monthly.loc[basket_monthly["month"] == to_month, "current_price"]
        if from_avg.empty or to_avg.empty:
            raise ValueError("No hay observaciones suficientes en los meses límite del rango")

        inflation_total_pct = float(((to_avg.iloc[0] - from_avg.iloc[0]) / from_avg.iloc[0]) * 100)

        top_categories = self._category_variation_from_indices(from_month, to_month, basket_type)
        data_source = "category_indices"
        if top_categories.empty:
            categories_grouped = self._monthly_avg_by(df, "category")
            top_categories = self._variation_between_months(categories_grouped, "category", from_month, to_month).head(10)
            top_categories["mom_change"] = pd.NA
            top_categories["yoy_change"] = pd.NA
            top_categories["products_included"] = pd.NA
            top_categories["products_missing"] = pd.NA
            data_source = "raw_prices"
        else:
            top_categories = top_categories.head(10)

        products_source = (
            df.sort_values(["canonical_id", "month"])
            .groupby(["canonical_id", "product_name", "month"], as_index=False)["current_price"]
            .mean()
        )
        top_products = self._variation_between_months(products_source, "canonical_id", from_month, to_month)
        top_products = top_products.merge(
            products_source[["canonical_id", "product_name"]].drop_duplicates("canonical_id"),
            on="canonical_id",
            how="left",
        ).head(10)

        coverage = self._coverage_metrics(df, from_month, to_month, basket_type)

        report_dir = Path("data/analysis/reports")
        report_dir.mkdir(parents=True, exist_ok=True)

        generated_at = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")
        timestamp = datetime.now(timezone.utc).strftime("%Y%m%d_%H%M%S")
        base_name = f"report_{from_month}_to_{to_month}_{timestamp}".replace("-", "")

        html_content = self._render_html(
            from_month=from_month,
            to_month=to_month,
            inflation_total_pct=inflation_total_pct,
            top_categories=top_categories,
            top_products=top_products,
            coverage=coverage,
            generated_at=generated_at,
        )

        html_path = report_dir / f"{base_name}.html"
        html_path.write_text(html_content, encoding="utf-8")

        pdf_path = None
        if export_pdf:
            pdf_path = self._write_pdf_if_requested(html_content, report_dir / f"{base_name}.pdf")

        metadata = {
            "generated_at": generated_at,
            "range": {"from": from_month, "to": to_month},
            "basket_type": basket_type,
            "data_source": data_source,
            "inflation_total_pct": inflation_total_pct,
            "coverage": coverage,
            "artifacts": {
                "html": str(html_path),
                "pdf": pdf_path,
            },
        }

        metadata_path = report_dir / f"{base_name}.metadata.json"
        metadata_path.write_text(json.dumps(metadata, ensure_ascii=False, indent=2), encoding="utf-8")

        return {
            "inflation_total_pct": inflation_total_pct,
            "top_categories": top_categories.to_dict(orient="records"),
            "top_products": top_products.to_dict(orient="records"),
            "coverage": coverage,
            "artifacts": ReportArtifacts(
                html_path=str(html_path),
                metadata_path=str(metadata_path),
                pdf_path=pdf_path,
            ).__dict__,
        }


def run_report(
    config_path: Optional[str],
    from_month: str,
    to_month: str,
    export_pdf: bool = False,
    basket_type: str = "cba",
) -> Dict[str, Any]:
    """Run report generation workflow."""
    config = load_config(config_path)
    with ReportGenerator(config) as generator:
        return generator.generate(
            from_month=from_month,
            to_month=to_month,
            export_pdf=export_pdf,
            basket_type=basket_type,
        )
