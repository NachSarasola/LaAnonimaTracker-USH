"""Reporting module for La Anónima Price Tracker.

Generates an HTML report (and optional PDF) for a selected date range.
"""

from __future__ import annotations

import json
from dataclasses import dataclass
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Dict, Optional

import pandas as pd
from loguru import logger

from src.config_loader import get_basket_items, load_config
from src.models import Price, Product, get_engine, get_session_factory


@dataclass
class ReportArtifacts:
    """Artifact paths generated by the reporting job."""

    html_path: str
    metadata_path: str
    pdf_path: Optional[str] = None


class ReportGenerator:
    """Build HTML/PDF report for inflation and coverage metrics."""

    def __init__(self, config: Dict[str, Any]):
        self.config = config
        engine = get_engine(config)
        session_factory = get_session_factory(engine)
        self.session = session_factory()

    def close(self):
        self.session.close()

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()

    def _month_start(self, value: str) -> pd.Timestamp:
        ts = pd.to_datetime(value, format="%Y-%m")
        return ts.to_period("M").to_timestamp()

    def _month_end(self, value: str) -> pd.Timestamp:
        return self._month_start(value) + pd.offsets.MonthEnd(1)

    def _load_prices(self, from_month: str, to_month: str) -> pd.DataFrame:
        start_dt = self._month_start(from_month)
        end_dt = self._month_end(to_month)

        query = (
            self.session.query(
                Price.canonical_id,
                Price.product_name,
                Price.basket_id,
                Price.current_price,
                Price.scraped_at,
                Product.category,
            )
            .outerjoin(Product, Price.canonical_id == Product.canonical_id)
            .filter(Price.scraped_at >= start_dt)
            .filter(Price.scraped_at <= end_dt)
        )

        df = pd.read_sql(query.statement, self.session.bind)
        if df.empty:
            return df

        df["scraped_at"] = pd.to_datetime(df["scraped_at"])
        df["month"] = df["scraped_at"].dt.to_period("M").astype(str)
        df["current_price"] = pd.to_numeric(df["current_price"], errors="coerce")
        df["category"] = df["category"].fillna("sin_categoria")
        return df.dropna(subset=["current_price"])

    def _monthly_avg_by(self, df: pd.DataFrame, group_col: str) -> pd.DataFrame:
        grouped = (
            df.groupby([group_col, "month"], as_index=False)["current_price"]
            .mean()
            .sort_values([group_col, "month"])
        )
        return grouped

    def _variation_between_months(self, grouped_df: pd.DataFrame, group_col: str, from_month: str, to_month: str) -> pd.DataFrame:
        from_df = grouped_df[grouped_df["month"] == from_month][[group_col, "current_price"]].rename(
            columns={"current_price": "price_from"}
        )
        to_df = grouped_df[grouped_df["month"] == to_month][[group_col, "current_price"]].rename(
            columns={"current_price": "price_to"}
        )
        merged = from_df.merge(to_df, on=group_col, how="inner")
        if merged.empty:
            return merged

        merged["variation_pct"] = ((merged["price_to"] - merged["price_from"]) / merged["price_from"]) * 100
        return merged.sort_values("variation_pct", ascending=False)

    def _coverage_metrics(self, df: pd.DataFrame, from_month: str, to_month: str) -> Dict[str, Any]:
        expected_products = len(get_basket_items(self.config, "all"))
        observed_total = int(df["canonical_id"].nunique()) if not df.empty else 0

        observed_from = int(df[df["month"] == from_month]["canonical_id"].nunique()) if not df.empty else 0
        observed_to = int(df[df["month"] == to_month]["canonical_id"].nunique()) if not df.empty else 0

        safe_expected = expected_products if expected_products > 0 else 1
        return {
            "expected_products": expected_products,
            "observed_products_total": observed_total,
            "coverage_total_pct": (observed_total / safe_expected) * 100,
            "observed_from": observed_from,
            "observed_to": observed_to,
            "coverage_from_pct": (observed_from / safe_expected) * 100,
            "coverage_to_pct": (observed_to / safe_expected) * 100,
        }

    def _render_html(
        self,
        from_month: str,
        to_month: str,
        inflation_total_pct: float,
        top_categories: pd.DataFrame,
        top_products: pd.DataFrame,
        coverage: Dict[str, Any],
        generated_at: str,
    ) -> str:
        categories_rows = "".join(
            f"<tr><td>{row['category']}</td><td>{row['price_from']:.2f}</td><td>{row['price_to']:.2f}</td><td>{row['variation_pct']:.2f}%</td></tr>"
            for _, row in top_categories.iterrows()
        ) or "<tr><td colspan='4'>Sin datos suficientes</td></tr>"

        products_rows = "".join(
            f"<tr><td>{row['canonical_id']}</td><td>{row['product_name']}</td><td>{row['price_from']:.2f}</td><td>{row['price_to']:.2f}</td><td>{row['variation_pct']:.2f}%</td></tr>"
            for _, row in top_products.iterrows()
        ) or "<tr><td colspan='5'>Sin datos suficientes</td></tr>"

        return f"""
<!DOCTYPE html>
<html lang=\"es\">
<head>
  <meta charset=\"UTF-8\" />
  <title>Reporte de inflación - La Anónima Tracker</title>
  <style>
    body {{ font-family: Arial, sans-serif; margin: 24px; color: #1f2937; }}
    h1, h2 {{ color: #111827; }}
    .muted {{ color: #6b7280; font-size: 14px; }}
    .card {{ border: 1px solid #e5e7eb; border-radius: 10px; padding: 14px; margin-bottom: 18px; }}
    .metric {{ font-size: 28px; font-weight: bold; color: #0f766e; }}
    table {{ width: 100%; border-collapse: collapse; margin-top: 10px; }}
    th, td {{ border: 1px solid #e5e7eb; padding: 8px; text-align: left; }}
    th {{ background: #f3f4f6; }}
  </style>
</head>
<body>
  <h1>Reporte de inflación de canasta</h1>
  <p class=\"muted\">Generado: {generated_at} | Rango analizado: {from_month} → {to_month}</p>

  <section class=\"card\">
    <h2>Inflación total canasta</h2>
    <p class=\"metric\">{inflation_total_pct:.2f}%</p>
  </section>

  <section class=\"card\">
    <h2>Top categorías con mayor suba</h2>
    <table>
      <thead><tr><th>Categoría</th><th>Precio promedio inicial</th><th>Precio promedio final</th><th>Variación</th></tr></thead>
      <tbody>{categories_rows}</tbody>
    </table>
  </section>

  <section class=\"card\">
    <h2>Top productos con mayor variación</h2>
    <table>
      <thead><tr><th>ID canónico</th><th>Producto</th><th>Precio inicial</th><th>Precio final</th><th>Variación</th></tr></thead>
      <tbody>{products_rows}</tbody>
    </table>
  </section>

  <section class=\"card\">
    <h2>Cobertura de datos</h2>
    <ul>
      <li>Productos esperados (config): {coverage['expected_products']}</li>
      <li>Productos observados (rango): {coverage['observed_products_total']} ({coverage['coverage_total_pct']:.2f}%)</li>
      <li>Productos observados en {from_month}: {coverage['observed_from']} ({coverage['coverage_from_pct']:.2f}%)</li>
      <li>Productos observados en {to_month}: {coverage['observed_to']} ({coverage['coverage_to_pct']:.2f}%)</li>
    </ul>
  </section>
</body>
</html>
"""

    def _write_pdf_if_requested(self, html_content: str, pdf_path: Path) -> Optional[str]:
        try:
            from weasyprint import HTML
        except Exception:
            logger.warning("No se pudo exportar PDF: weasyprint no está disponible")
            return None

        HTML(string=html_content).write_pdf(str(pdf_path))
        return str(pdf_path)

    def generate(self, from_month: str, to_month: str, export_pdf: bool = False) -> Dict[str, Any]:
        if self._month_start(to_month) < self._month_start(from_month):
            raise ValueError("El rango es inválido: --to debe ser mayor o igual que --from")

        df = self._load_prices(from_month, to_month)
        if df.empty:
            raise ValueError("No hay datos de precios para el rango indicado")

        basket_monthly = df.groupby("month", as_index=False)["current_price"].mean()
        from_avg = basket_monthly.loc[basket_monthly["month"] == from_month, "current_price"]
        to_avg = basket_monthly.loc[basket_monthly["month"] == to_month, "current_price"]
        if from_avg.empty or to_avg.empty:
            raise ValueError("No hay observaciones suficientes en los meses límite del rango")

        inflation_total_pct = float(((to_avg.iloc[0] - from_avg.iloc[0]) / from_avg.iloc[0]) * 100)

        categories_grouped = self._monthly_avg_by(df, "category")
        top_categories = self._variation_between_months(categories_grouped, "category", from_month, to_month).head(10)

        products_source = (
            df.sort_values(["canonical_id", "month"])
            .groupby(["canonical_id", "product_name", "month"], as_index=False)["current_price"]
            .mean()
        )
        top_products = self._variation_between_months(products_source, "canonical_id", from_month, to_month)
        top_products = top_products.merge(
            products_source[["canonical_id", "product_name"]].drop_duplicates("canonical_id"),
            on="canonical_id",
            how="left",
        ).head(10)

        coverage = self._coverage_metrics(df, from_month, to_month)

        report_dir = Path("data/analysis/reports")
        report_dir.mkdir(parents=True, exist_ok=True)

        generated_at = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")
        timestamp = datetime.now(timezone.utc).strftime("%Y%m%d_%H%M%S")
        base_name = f"report_{from_month}_to_{to_month}_{timestamp}".replace("-", "")

        html_content = self._render_html(
            from_month=from_month,
            to_month=to_month,
            inflation_total_pct=inflation_total_pct,
            top_categories=top_categories,
            top_products=top_products,
            coverage=coverage,
            generated_at=generated_at,
        )

        html_path = report_dir / f"{base_name}.html"
        html_path.write_text(html_content, encoding="utf-8")

        pdf_path = None
        if export_pdf:
            pdf_path = self._write_pdf_if_requested(html_content, report_dir / f"{base_name}.pdf")

        metadata = {
            "generated_at": generated_at,
            "range": {"from": from_month, "to": to_month},
            "inflation_total_pct": inflation_total_pct,
            "coverage": coverage,
            "artifacts": {
                "html": str(html_path),
                "pdf": pdf_path,
            },
        }

        metadata_path = report_dir / f"{base_name}.metadata.json"
        metadata_path.write_text(json.dumps(metadata, ensure_ascii=False, indent=2), encoding="utf-8")

        return {
            "inflation_total_pct": inflation_total_pct,
            "top_categories": top_categories.to_dict(orient="records"),
            "top_products": top_products.to_dict(orient="records"),
            "coverage": coverage,
            "artifacts": ReportArtifacts(
                html_path=str(html_path),
                metadata_path=str(metadata_path),
                pdf_path=pdf_path,
            ).__dict__,
        }


def run_report(config_path: Optional[str], from_month: str, to_month: str, export_pdf: bool = False) -> Dict[str, Any]:
    """Run report generation workflow."""
    config = load_config(config_path)
    with ReportGenerator(config) as generator:
        return generator.generate(from_month=from_month, to_month=to_month, export_pdf=export_pdf)
